# 전략 패턴이란? #

## 개요 ##
알고리즘들의 패밀리를 정의하고, 각 패밀리를 별도의 클래스에 넣은 후 그들의 객체들을 상호교환할 수 있도록 하는 행동 디자인 패턴입니다.

## 문제 ##
어느 날 당신은 여행자들을 위한 내비게이션 프로그램을 만들기로 했습니다. 프로그램의 중심 기능은 사용자들이 어느 도시에서든 빠르게 방향을 잡을 수 있도록 도와주는 아름다운 지도였습니다.

프로그램에서 가장 많이 요청된 기능 중 하나는 자동 경로 계획 기능이었습니다. 사용자가 주소를 입력하면 지도에 표시된 해당 목적지로 가는 가장 빠른 경로를 볼 수 있는 기능이었죠.

프로그램의 첫 번쨰 버전에서는 도로로 된 경로만을 만들 수 있었습니다. 차를 타고 여행하는 사용자들은 만족했습니다. 하지만 모든 사용자가 여가 중에 운전하는 걸 좋아하진 않았습니다. 그래서 그 다음 업데이트에서는 도보 경로를 만드는 옵션을 추가했습니다. 바로 그 다음에는 사람들이 경로에서 대중교통의 사용을 계획할 수 있도록 옵션을 추가했습니다.

하지만 그것은 시작에 불과했습니다. 나중에는 자전거를 타는 사용자들을 위한 경로로 만들 계획을 세웠습니다. 심지어 그 다음에는 도시의 모든 관광 명소들을 지나는 경로를 만들 수 있는 또 다른 옵션을 추가할 계획을 세웠습니다.

사업적인 측면에서 프로그램은 성공했지만, 기술적인 문제들이 많은 골칫거리를 야기했습니다. 새 경로 구축 알고리즘을 추가할 때마다 네비게이터의 메인 클래스의 크기가 두 배로 늘어났으며, 어느 시점이 되자 네비게이션 프로그램을 유지하기가 너무 어려워졌습니다.

간단한 버그를 수정하거나 주행거리 점수를 살짝 조정하기 위해 알고리즘 중 하나를 변경하면 전체 클래스에 영향이 미쳐 이미 작동하는 코드에서 오류가 발생할 가능성이 높아졌습니다.

또한 팀워크가 비효율적이 되었습니다. 프로그램 출시 직후 고용된 팀원들은 병합 충돌을 해결하는데 너무 많은 시간을 할애해야 한다고 불평했습니다. 또 새로운 기능을 구현하려면 거대한 동일 클래스를 변경해야 했는데, 이렇게 바꾼 내용들이 다른 팀원들이 생성한 코드와 충돌하곤 했습니다.

## 해결책 ##
전략 패턴은 특정 작업을 다양한 방식으로 수행하는 클래스를 선택한 후 모든 알고리즘을 "전략"이라는 별도의 클래스들로 추출할 것을 제안합니다.

컨텍스트라는 원래 클래스에는 전략 중 하나에 대한 참조를 저장하기 위한 필드가 있어야 합니다. 컨텍스트는 작업을 자체적으로 실행하는 대신 연결된 전략 객체에 위임합니다.

컨텍스트는 작업에 적합한 알고리즘을 선택할 책임이 없습니다. 대신 클라이언트가 원하는 전략을 컨텍스트에 전달합니다. 사실, 컨텍스트는 전략들에 대해 많이 알지 못합니다. 컨텍스트는 같은 일반 인터페이스를 통해 모든 전략과 함께 작동하며, 이 일반 인터페이스는 선택된 전략 내에 캡슐화된 알고리즘을 작동시킬 단일 메서드만 노출합니다.

이렇게 하면 컨텍스트가 구상 전략들에 의존하지 않게 되므로 컨텍스트 또는 다른 전략들의 코드를 변경하지 않고도 새 알고리즘들을 추가하거나 기존 알고리즘들을 수정할 수 있습니다.

당신의 네비게이션 프로그램에서 각 경로 구축 알고리즘을 단일 "경로" 메서드를 사용하여 자체 클래스로 추출할 수 있습니다. 이 메서드는 출발지와 목적지를 받은 후 경로의 체크포인트들의 컬렉션을 반환합니다.

같은 인수가 주어졌더라도 각 경로 구축 클래스는 다른 경로를 구축할 수 있지만 주 네비게이터 클래스는 어떤 알고리즘이 선택되었는지 별로 신경쓰지 않습니다. 왜냐하면 주 네비게이터 클래스의 주요 작업은 지도에 체크포인트들의 집합을 랜더링하는 것이기 때문입니다. 이 클래스에는 활성 경로 구축 전력을 전환하는 메서드가 있어, 클래스의 클라이언트들이 현재 선택된 경로 구축 행동들을 다른 행동으로 대체할 수 있습니다.

## 실제상황 예시 ##
공항에 가야한다고 상상해보세요. 당신은 버스를 탈 수도 있고, 택시나 자전거를 탈 수도 있습니다. 이것들이 바로 당신의 운송 전략들입니다. 예산이나 시간 제약 등을 고려하여 이러한 전략 중 하나를 선택할 수 있습니다.

## 의사코드 ##
이 예시에서의 컨텍스트는 여러 전략들을 사용하여 다양한 산술 연산들을 실행합니다.

```
interface Strategy {
	execute(a: number, b: number);
}

class ConcreteStrategyAdd implements Strategy {
	execute(a: number, b: number) {
        return a + b
	}
}

class ConcreteStrategySubtract implements Strategy {
    execute(a: number, b: number) {
    	return a - b
	}
}

class ConcreteStrategyMultiply implements Strategy {
    execute(a: number, b: number) {
    	return a * b 
	}
}

class Context {
	private strategy: Strategy;

	setStrategy(strategy: Strategy) {
		this.strategy = strategy
	}

	executeStrategy(a: number, b: number) {
		return this.strategy.execute(a, b)
	}
}

class App {
	main() {
		const context = new Context();

		let a = 5;
		let b = 6;

        if (action == addition) then
            context.setStrategy(new ConcreteStrategyAdd())

        if (action == subtraction) then
            context.setStrategy(new ConcreteStrategySubtract())

        if (action == multiplication) then
            context.setStrategy(new ConcreteStrategyMultiply())

        const result = context.executeStrategy(a, b);
	}
}
```

## 적용 ##

### 전략 패턴은 객체 내에서 한 알고리즘의 다양한 변형들을 사용하고 싶을 때, 그리고 런타임 중에 한 알고리즘에서 다른 알고리즘으로 전환하고 싶을 때 사용하세요. ###
또 전략 패턴은 객체의 행동들을 특정 하위 행동들을 다양한 방식으로 수행할 수 있는 다른 하위 객체들과 연관시켜 객체의 행동들을 런타임에 간접적으로 변경할 수 있게 해줍니다.

### 전략 패턴은 일부 행동을 실행하는 방식에서만 차이가 있는 유사한 클래스들이 많은 경우에 사용하세요. ###
전략 패턴은 다양한 행동들을 별도의 클래스 계층구조로 추출하고 원래 클래스들을 하나로 결합하여 중복 코드를 줄일 수 있게 해줍니다.

### 전략 패턴을 사용하여 클래스의 비즈니스 로직을 해당 로직의 컨텍스트에서 그리 중요하지 않을지도 모르는 알고리즘들의 구현 세부 사항들로부터 고립하세요. ###
전략 패턴은 코드의 나머지 부분에서 해당 코드, 내부 데이터, 그리고 다양한 알고리즘들의 의존 관계를 고립시킬 수 있습니다. 다양한 클라이언트들이 알고리즘들을 실행하고 런타임에 전환하기 위한 간단한 인터페이스를 얻습니다.

### 이 패턴은 같은 알고리즘의 다른 변형들 사이들 전환하는 거대한 조건문이 당신의 클래스에 잇는 경우에 사용하세요. ###
전략 패턴을 사용하면 모든 알고리즘의 같은 인터페이스를 구현하는 별도의 클래스들로 추출하여 이러한 조건문을 제거할 수 있습니다. 원래 객체는 알고리즘의 모든 변형들을 구현하는 대신 이러한 객체들 중 하나에 실행을 위임합니다.

## 구현 방법 ##
1. 컨텍스트 클래스에서 자주 변경되는 알고리즘을 식별하세요. 런타임에 같은 알고리즘의 변형을 선택한 후 실행하는 거대한 조건문일 수 도 있습니다.
2. 알고리즘의 모든 변형에 공통적인 전략 인터페이스를 선언하세요.
3. 하나씩 모든 알고리즘을 자체 클래스들로 추출하세요. 그들은 모두 전략 인터페이스를 구현해야 합니다.
4. 컨텍스트 클래스에서 전략 객체에 대한 참조를 저장하기 위한 필드를 추가한 후, 해당 필드의 값을 대체하기 위한 setter를 제공하세요. 컨텍스트는 전략 인터페이스를 통해서만 전략 객체와 작동해야 합니다. 컨텍스트는 인터페이스를 정의할 수 있으며, 이 인터페이스는 전략이 컨텍스트의 데이터에 접근할 수 있도록 합니다.
5. 컨텍스트의 클라이언트들은 컨텍스트를 적절한 전략과 연관시켜야 합니다. 이러한 전략은 클라이언트들이 기대하는 컨텍스트가 주 작업을 수행하는 방식과 일치해야 합니다.

## 장점 ##
1. 런타임에 한 객체 내부에서 사용되는 알고리즘들을 교환할 수 있습니다.
2. 알고리즘을 사용하는 코드에서 알고리즘의 구현 세부 정보들을 고립할 수 있습니다.
3. 상속을 합성으로 대체할 수 있습니다.
4. 개방/페쇄 원칙: 컨텍스트를 변경하지 않고도 새로운 전략들을 도입할 수 있습니다.

## 단점 ##
1. 알고리즘이 몇개밖에 되지 않고 거의 변하지 않는다면, 패턴과 함께 사용되는 새로운 클래스들과 인터페이스들로 프로그램을 지나치게 복잡하게 만들 이유가 없습니다.
2. 클라이언트들은 적절한 전략을 선택할 수 있도록 전략 간의 차이점들을 알고 있어야 합니다.
3. 현대의 많은 프로그래밍 언어에는 익명 함수들의 집합 내에서 알고리즘의 다양한 버전을 구현할 수 있는 함수형 지원이 있으며, 클래스들과 인터페이스들을 추가하여 코드의 부피를 늘리지 않으면서도 전략 객체를 사용했을 때와 똑같이 이러한 함수들을 사용할 수 있습니다.
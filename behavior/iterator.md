# 반복자 패턴이란?

## 개요
컬렉션의 요소들의 기본 표현(리스트, 스택, 트리등)을 노출하지 않고 그들을 하나씩 순회할 수 있도록 하는 행동 디자인 패턴입니다.

## 문제
컬렉션은 프로그래밍에서 가장 많이 사용되는 데이터 유형 중 하나이긴 하지만, 객체 그룹의 단순한 컨테이너에 불과합니다.

대부분의 컬렉션들은 그들의 요소들을 간단한 리스트들에 저장하나, 그 중 일부는 스택, 트리, 그래프 및 기타 복잡한 데이터 구조들을 기반으로 합니다.

그러나 컬렉션이 어떻게 구성되어 있는지를 떠나서, 컬렉션은 그 요소들을 접근할 수 있는 어떤 방법을 다른 코드에 제공해야 합니다. 그래야 다른 코드가 이 요소들을 사용할 수 있습니다. 같은 요소에 반복해서 접근하지 않고 컬렉션의 각 요소를 순회하는 방법이 있을 것 입니다.

리스트로 된 컬렉션이 있다면 아주 쉽게 해결할 수 있을 겁니다. 모든 요소를 루프로 처리하면 되니까요. 하지만 트리처럼 복잡한 데이터 구조의 요소들은 어떻게 순차적으로 순회해야 할까요? 예를 들어 어떤 날은 트리의 깊이를 우선으로 순회하는 것이 적절할지도 모릅니다. 하지만 그 다음날에는 너비를 우선으로 순회해야 할 수도 있습니다. 그리고 그 다음주에는 트리 요소들에 대한s 임의 접근등 다른 방식의 순회가 필요할지도 모릅니다.

현재 컬렉션의 주요 책임은 효율적인 데이터 저장이나, 컬렉션에 더 많은 순회 알고리즘들을 추가할수록 컬렉션의 주요 책임이 무엇인지 점점 명확해지지 않게 됩니다. 또한 일부 알고리즘들은 특정 앱에 맞게 조정되었을 수 있으므로 일반적인 컬렉션 클래스에 이들을 포함하는 것은 이상할 수 있습니다.

반면에 다양한 컬렉션들과 작동해야 하는 클라이언트 코드는 자신들의 요소가 어떻게 저장되는지 관심을 두지 않습니다. 하지만 컬렉션마다 그 요소들에 접근할 수 있도록 허용하는 방법이 다르므로, 당신은 코드를 특정한 컬렉션 클래스에 결합할 수밖에 없습니다.

## 해결책
반복자 패턴의 주 아이디어는 컬렉션의 순회 동작을 반복자라는 별도의 객체로 추출하는 것입니다.

반복자 객체는 알고리즘 자체를 구현하는 것 외에도 모든 순회 세부 정보들을 캡슐화하며, 이 때문에 여러 반복자들이 서로 독립적으로 동시에 같은 컬렉션을 통과할 수 있습니다.

일반적으로 반복자들은 컬렉션의 요소들을 가져오기 위한 하나의 주 메서드를 제공합니다. 클라이언트는 이 메서드를 더 이상 아무것도 반환하지 않을 때까지 계속 실행할 수 있습니다. 이는 반복자가 모든 요소를 순회했음을 의미합니다.

모든 반복자들은 같은 인터페이스를 구현해야 합니다. 이렇게 하면 적절한 반복자가 있는 한 클라이언트 코드는 모든 컬렉션 유형들 및 순회 알고리즘들과 호환됩니다. 컬렉션을 순회하는 특별한 방법이 필요하면 컬렉션이나 클라이언트를 변경할 필요 없이 새 반복자 클래스를 만들기만 하면 됩니다.

## 실제상황 예시
당신은 며칠 동안 로마를 방문하고 주요 명소들을 모두 방문할 계획을 세웠습니다. 그러나 막상 도착한 후 당신은 콜로세움조차 찾지 못하고 제자리를 멤도는 데 많은 시간을 허비할 수 있습니다.

위 사례의 대안으로 스마트폰용 가상 가이드 프로그램을 구매하여 네비게이션에 사용할 수 있습니다. 이 프로그램은 똑똑하고 저렴하며 실제 가이드와 달리 원하는 만큼 흥미로운 장소에 머물 수 있도록 합니다.

다음 대안은 조금 더 비싸더라도 도시를 잘 아는 현지 가이드를 고용하는 것입니다. 현지 가이드는 당신의 취향에 맞게 여행을 조정하고 모든 명소를 보여주며 흥미진진한 이야기들을 많이 알려줄 수 있습니다. 이 대안을 선택하면 재미는 있겠지만, 더 많은 비용이 들게 될 것입니다.

이 모든 대안들은 로마의 많은 관광명소에 대해 반복자들로 작동합니다.

## 의사코드
이 예시에서 반복자 패턴은 페이스북의 소셜 그래프에 대한 접근을 캡슐화하는 특별한 종류의 컬렉션을 순회하는 데 사용합니다. 이 컬렉션은 다양한 방식으로 프로필들을 순회할 수 있는 여러 반복자들을 제공합니다.

"친구들" 반복자는 주어진 프로필의 친구들을 탐색하는 데 사용될 수 있습니다. "동료들" 반복자는 프로필 주인과 같은 회사에서 일하지 않는 친구들을 제외한 후 같은 작업을 수행합니다. 두 반복자 모두 인증 및 REST 요청 전송과 같은 구현 세부 사항들을 자세히 살펴보지 않고도 클라이언트들이 프로필들을 가져올 수 있도록 하는 공통 인터페이스를 구현합니다.

클라이언트 코드는 인터페이스들을 통해서만 컬렉션들 및 반복자들과 작업하기 때문에 구상 클래스들과 결합하지 않습니다. 프로그램을 새로운 소셜 네트워크에 연결하기로 했다면 기존 코드를 변경하지 않고 새로운 컬렉션 및 반복자 클래스들을 제공하기만 하면 됩니다.

```
interface SocialNetwork {
	createFriendsIterator(profileId): ProfileIterator;
	createCoworkersIterator(profileId): ProfileIterator;
}

class Facebook implements SocialNetwork {
	createFriendsIterator(profileId): ProfileIterator {
		return new FacebookIterator(this, profileId, "friends");
	}

	createCoworkersIterator(profileId): ProfileIterator {
		return new FacebookIterator(this, profileId, "coworkers");
	}
}

interface ProfileIterator {
	getNext(): Profile;
	hasMore(): boolean;
}

class FacebookIterator implements ProfileIterator {
	private facebook: Facebook;
	private profileId: string;
	private type: string;
	private currentPosition;
	private cache: Profile[];

	constructor(facebook, profileId, type) {
		this.facebook = facebook;
        this.profileId = profileId;
        this.type = type;
	}

	private lazyInit() {
		if (this.cache == null)
        	this.cache = facebook.socialGraphRequest(this.profileId, this.type);
	}

	getNext() {
		if (hasMore())
            this.currentPosition++;
            return this.cache[currentPosition];	
	}

    hasMore() {
		this.lazyInit();
        return this.currentPosition < this.cache.length;
	}
}

class SocialSpammer {
    send(iterator: ProfileIterator, message: string) {
        while (iterator.hasMore()) {
            this.profile = iterator.getNext()
            System.sendEmail(this.profile.getEmail(), message)
		}
	}
}

class App {
    network: SocialNetwork;
    spammer: SocialSpammer;

    config() {
		if working with Facebook
            this.network = new Facebook()
        if working with LinkedIn
            this.network = new LinkedIn()
        this.spammer = new SocialSpammer()
	}

	sendSpamToFriends(profile) {
        iterator = this.network.createFriendsIterator(profile.getId())
        this.spammer.send(iterator, "Very important message")
	}

    sendSpamToCoworkers(profile) {
        iterator = this.network.createCoworkersIterator(profile.getId())
        this.spammer.send(iterator, "Very important message")
	}
}
```

## 적용

### 반복자 패턴은 당신의 컬렉션이 내부에 복잡한 데이터 구조가 있지만 이 구조의 복잡성을 보안이나 편의상의 이유로 클라이언트들로부터 숨기고 싶을 때 사용하세요.
반복자는 복잡한 데이터 구조와 작업 시의 세부 사항을 캡슐화하여 클라이언트에 컬렉션 요소들에 접근할 수 있는 몇 가지 간단한 메서드들을 제공합니다. 이 접근 방식은 클라이언트에게 매우 편리합니다. 또 클라이언트가 컬렉션과 직접 작동할 때 클라이어트가 수행할 수 있는 부주의하거나 악의적인 행동들로부터 컬렉션을 보호합니다.

### 반복자 패턴을 사용하여 당신의 프로그램 전체에서 순회 코드의 중복을 줄이세요.
사소하지 않은 순회 알고리즘들의 코드는 부피가 매우 큰 경향이 있습니다. 이 코드들이 프로그램의 비즈니스 로직 내에 배치되면 원래 코드의 책임이 무엇인지 모호해질 수 있으며 코드의 유지관리가 더 어려워질 수 있습니다. 순회 코드를 지정된 반복자들로 이동하면 당신 프로그램의 코드가 더 간결하고 깔끔해질 수 있습니다.

### 반복자 패턴은 코드가 다른 데이터 구조들을 순회할 수 있기를 원할 때 또는 이러한 구조들의 유형을 미리 알 수 없을 때 사용하세요.
이 패턴은 컬렉션과 반복자들 모두에 몇 개의 일반 인터페이스들을 제공합니다. 당신의 코드가 이러한 인터페이스들을 사용한다는 점을 고려할 때, 이러한 인터페이스들은 그들을 구현하는 다양한 컬렉션들 및 반복자들을 전달받아도 여전히 작동합니다.

## 구현 방법
1. 반복자 인터페이스를 선언하세요. 이 인터페이스는 최소한 컬렉션에서 다음 요소를 가져오는 메서드가 있어야 하며, 또 편의를 위해 여기에 몇 가지 다른 메서드들도 추가할 수 있습니다.
2. 컬렉션 인터페이스를 선언하고 반복자를 가져오는 메서드를 설명하세요. 컬렉션 인터페이스의 반환 유형은 반복자 인터페이스의 유형과 같아야 합니다. 뚜렷하게 다른 여러 개의 반복자들의 그룹을 가질 계획이라면 유사한 메서드들을 선언할 수 있습니다.
3. 반복자들이 순회하게 할 수 있도록 하고 싶은 컬렉션들에 대한 구상 반복자 클래스들을 구현하세요. 반복자 객체는 단일 컬렉션 인스턴스와 반드시 연결되어야 합니다. 일반적으로 이러한 연결은 반복자의 생성자를 통해 맺어집니다.
4. 당신의 컬렉션 클래스들에서 컬렉션 인터페이스를 구현하세요. 그 주된 목적은 클라이언트에 특정 컬렉션 클래스에 맞게 조정된 반복자들을 생성하기 위한 바로 가기를 제공하는 것입니다. 컬렉션 객체는 반복자의 생성자에 자신을 전달해야 하며 이 둘 사이에 연결을 맺어야 합니다.
5. 클라이언트 코드를 살펴보면서 반복자들을 사용하여 모든 컬렉션 순회 코드들을 교체하세요. 클라이언트는 컬렉션 요소들을 순회해야 할 때마다 새 반복자 객체를 가져옵니다.

## 장점
1. 단일 책임 원칙: 부피가 큰 순회 알고리즘들을 별도의 클래스들로 추출하여 클라이언트 코드와 컬렉션들을 정돈할 수 있습니다.
2. 개방/폐쇄 원칙: 새로운 유형의 컬렉션들과 반복자들을 구현할 수 있으며 이들을 아무것도 훼손하지 않은 채 기존의 코드에 전달할 수 있습니다.
3. 당신은 이제 같은 컬렉션을 병렬로 순회할 수 있습니다. 왜냐하면 각 반복자 객체에는 자신의 고유한 순회 상태가 포함되어 있기 때문입니다.
4. 같은 이유로 당신은 순회를 지연하고 필요할 때 계속할 수 있습니다.

## 단점
1. 당신의 프로그램이 단순한 컬렉션들과만 작동하는 경우 반복자 패턴을 적용하는 것은 과도할 수 있습니다.
2. 반복자를 사용하는 것은 일부 특수 컬렉션들의 요소들을 직접 탐색하는 것보다 덜 효율적일 수 있습니다.
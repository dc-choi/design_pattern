# 팩토리패턴이란? #

## 개요 ##
부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만, 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있도록 하는 생성 패턴

## 문제 ##
물류 관리 프로그램을 개발한다고 가정했을 때 트럭 운송만 생각하여 대부분의 코드가 "트럭" 클래스에 있습니다.

얼마 후, 프로그램이 유명해졌고, 매일 해상 물류 회사들로부터 해상 물류 기능을 앱에 추가해 달라는 요청을 수십 개씩 받기 시작했습니다.

프로그램에 "배" 클래스를 추가하려면 전체 코드 베이스를 변경해야 합니다. 또한 추후 프로그램에 다른 유형의 교통수단을 추가하려면 다시 전체 코드 베이스를 변경해야 합니다.

그러면 결과적으로 많은 조건문이 운송 수단 객체들의 클래스에 따라 프로그램의 행동을 바꾸는 매우 복잡한 코드가 됩니다.

## 해결책 ##
팩토리 패턴은 new 연산자를 사용한 객체 생성 직접 호출들을 특별한 팩토리 메서드에 대한 호출들로 대체하라고 제안합니다.

객체들은 여전히 new 연산자를 통해 생성되지만 팩토리 메서드 내에서 호출되고 있습니다.

참고로 메서드에서 반환된 객체는 종종 "제품"이라고도 불립니다.

얼핏 이러한 변경은 무의미해 보일 수도 있는데, 그 이유는 생성자 호출을 프로그램의 한 부분에서 다른 부분으로 옮겼을 뿐입니다.

그러나 위와 같은 변경 덕분에 이제 자식 클래스에서 팩토리 메서드를 오버라이딩하고 그 메서드에 의해 생성되는 제품들의 클래스를 변경할 수 있게 되었습니다.

하지만 약간의 제한이 있긴 합니다. 자식 클래스들은 다른 유형의 제품들을 해당 제품들이 공통 추상 클래스 또는 공통 인터페이스가 있는 경우에만 반환할 수 있습니다.

또 이전에 언급한 모든 제품들에 공통인 "운송" 인터페이스로 "물류" 추상 클래스의 "배송수단생성" 팩토리 메서드의 반환 유형을 선언해야 합니다.

예를 들어 "트럭"과 "배" 클래스들은 모두 "운송" 인터페이스를 구현해야 하며, 이 인터페이스는 "배달"이라는 메서드를 선언합니다.

그러나 각 클래스는 이 메서드를 다르게 구현합니다. 트럭은 육로로 화물을 배달하고 선박은 해상으로 화물을 배달합니다.

"도로물류" 클래스에 포함된 팩토리 메서드는 "트럭" 객체들을 반환하는 반면 "해운물류" 클래스에 포함된 팩토리 메서드는 "배" 객체를 반환합니다.

팩토리 메서드를 사용하는 코드를 종종 "클라이언트 코드"라고 부르며, "클라이언트 코드"는 다양한 자식 클래스들에서 실제로 반환되는 여러 제품 간의 차이에 대해 알지 못합니다.

"클라이언트 코드"는 모든 제품을 추상 "운송"으로 간주합니다. 클라이언트는 모든 "운송" 객체들이 "배달"메서드를 가져야 한다는 사실을 잘 알고 있지만, 이 메서드가 정확히 어떻게 작동하는지는 클라이언트에게 중요하지 않습니다.

## 의사코드 ##
추상 "대화 상자" 클래스는 여러 UI 요소들을 사용하여 대화 상자를 렌더링합니다.

다양한 운영 체제에서 이러한 요소들은 약간씩 다르게 보일 수 있지만 여전히 일관되게 작동해야 합니다.

예를 들어 윈도우에서의 버튼은 리눅스에서도 여전히 버튼이여야 합니다.

팩토리 패턴이 적용되면, 당신은 "대화 상자" 로직을 각 운영 체제를 위하여 반복해서 재 작성할 필요가 없습니다.

추상 "대화 상자" 클래스 내에서 버튼을 생성하는 팩토리 메서드를 선언하면 나중에 팩토리 메서드에서 윈도우 유형의 버튼들을 반환하는 "대화 상자" 자식 클래스를 생성할 수 있습니다.

그 후 이 자식 클래스는 추상 클래스로부터 "대화 상자"의 코드 대부분을 상속받으나, 팩토리 패턴 덕분에 윈도우 유형의 버튼들도 렌더링 할 수 있습니다.

이 패턴이 작동하려면 추상 "대화 상자" 클래스가 추강 버튼들과 함께 작동해야 합니다. (참고로 추상 버튼은 모든 구상 버튼들이 따르는 인터페이스 또는 추상 클래스입니다.)

이렇게 해야 다이얼로그 코드가 버튼 유형에 관계 없이 작동합니다.

물론, 위 접근 방식을 다른 UI요소들에도 적용할 수 있으나, 대화 상자에 새로운 팩토리 메서드를 추가할 때마다 이 프로그램은 "추상 팩토리 패턴"에 더 가까워 집니다.

```
abstract class Dialog {
	abstract createButten(): Butten;

	render() {
		// 팩토리 메서드를 호출해 제품 객체 생성
		Butten okButten = createButten();
		okButten.onClick();
		okButten.render();
	};
}

class WindowsDialog extends Dialog {
	createButten(): Butten {
		return new WindowsButten();
	}
}

class WebDialog extends Dialog {
	createButten(): Butten {
		return new HTMLButten();
	}
}

interface Butten {
	render();
	onClick();
}

class WindowsButten implements Butten {
	render() {
		// 윈도우 스타일로 정의
	}

	onClick() {
		// 윈도우 스타일로 정의
	}
}

class WebButten implements Butten {
	render() {
		// 웹 스타일로 정의
	}

	onClick() {
		// 웹 스타일로 정의
	}
}

class App {
	dialog: Dialog;

	setOSEnv() {
		// 환경변수 설정
	}

	main() {
		this.setOSEnv();

		if (env.OS === 'Windows') {
			this.dialog = new WindowsDialog();
		} else if (env.OS === 'Web') {
			this.dialog = new WebDialog();
		} else {
			throw Error('OS 설정이 안됨.');
		}

		dialog.render();
	}
}

const app = new App();
```

## 적용 ##

### 팩토리 패턴은 당신의 코드가 함께 작동해야 하는 객체들의 정확한 유형들과 의존관계들을 미리 모르는 경우 사용하세요. ###
팩토리 패턴은 제품 생성 코드를 제품을 실제로 사용하는 코드와 분리합니다. 그러면 제품 생성자 코드를 나머지 코드와는 독립적으로 확장하기 쉬워집니다.

예를 들어, 프로그램에 새로운 제품을 추가하려면 당신은 새로운 자식 클래스를 생성한 후 해당 클래스 내부의 팩토리 메서드를 오버라이딩하기만 하면 됩니다.

### 팩토리 패턴은 기존 객체들을 매번 재구축하는 대신 이들을 재사용하여 시스템 리소스를 절약하고 싶을 때 사용하세요. ###
이러한 요구사항은 데이터베이스 연결, 파일 시스템 및 네트워크처럼 시스템 자원을 많이 사용하는 대규모 객체들을 처리할 때 자주 발생합니다.

기존 객체를 재사용하려면 무엇을 해야 하는지 예시를 통해 설명해보겠습니다.

1. 먼저 생성된 모든 객체를 추적하기 위해 스토리지를 생성합니다.
2. 누군가가 객체를 요청하면 프로그램은 해당 풀 내에서 유휴 객체를 찾아야합니다.
3. 그후 이 객체를 클라이언트 코드에 반환해야 합니다.
4. 유휴 객체가 없으면 프로그램은 새로운 객체를 생성해야 합니다.
5. 새로운 객체를 풀에 추가해야 합니다.

이것은 정말로 많은 양의 코드입니다. 그리고 프로그램을 중복 코드로 오염시키지 않도록 이 많은 양의 코드를 모두 한곳에 넣어야 합니다.

아마도 이 코드를 배치할 수 있는 가장 확실하고 편리한 위치는 우리가 재사용하려는 객체들의 클래스의 생성자일 것입니다.

그러나 생성자는 특성상 항상 새로운 객체들을 반환해야 하며, 기존 인스턴스를 반환할 수 없습니다.

따라서 새 객체를 생성하고 기존 객체를 재사용할 수 있는 일반적인 메서드가 필요합니다.

## 구현 방법 ##
1. 모든 제품이 같은 인터페이스를 따르도록 하세요. 이 인터페이스는 모든 제품에서 의미가 있는 메서드들을 선언해야 합니다.
2. 클래스 내부에 빈 팩토리 메서드를 추가하세요. 이 메서드의 반환 유형은 공통 제품 인터페이스와 일치해야 합니다.
3. 코드에서 제품 생성자들에 대한 모든 참조를 찾으세요. 이 참조들을 하나씩 팩토리 메서드에 대한 호출로 교체하면서 제품 생성 코드를 팩토리 메서드로 추출하세요. 반환된 제품의 유형을 제어하기 위해 팩토리 메서드에 임시 매개변수를 추가해야 할 수도 있습니다.
4. 이제 팩토리 메서드에 나열된 각 제품 유형에 대한 자식 클래스들의 집합을 생성한 후, 자식 클래스들에서 팩토리 메서드를 오버라이딩하고 추상 메서드에서 생성자 코드의 적절한 부분들을 추출하세요.
5. 제품 유형이 너무 많이 모든 제품에 대한 자식 클래스들을 만드는 것이 합리적이지 않을 경우, 자식 클래스들의 추상 클래스의 제어 매개변수를 재사용할 수 있습니다.
6. 추출이 모두 끝난 후 추상 팩토리 메서드가 비어 있으면, 해당 팩토리 메서드를 추상화할 수 있습니다. 팩토리 메서드가 비어 있지 않으면, 나머지를 그 메서드의 기본 행동으로 만들 수 있습니다.

## 장점 ##
1. 구상 제품들이 서로 단단하게 결합되지 않도록 할 수 있습니다.
2. 단일 책임 원칙: 제품 생성 코드를 프로그램의 한 위치로 이동하여 코드를 더 쉽게 유지관리 할 수 있습니다.
3. 개방/폐쇄 원칙: 당신은 기존 클라이언트 코드를 훼손하지 않고 새로운 유형의 제품들을 프로그램에 도입할 수 있습니다.

## 단점 ##
1. 패턴을 구현하기 위해 많은 새로운 자식 클래스들을 도입해야 하므로 코드가 더 복잡해 질 수 있음. 가장 좋은 방법은 클래스들의 기존 계층구조에 패턴을 도입하는 것.
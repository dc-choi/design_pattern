# 추상 팩토리패턴이란?

## 개요
관련 객체들의 구상 클래스들을 지정하지 않고도 관련 객체들의 모음을 생성할 수 있도록 하는 생성패턴입니다.

## 문제
예를 들어 당신이 가구 판매장을 위한 프로그램을 만들고 있다고 가정합시다. 당신의 코드는 다음을 나타내는 클래스들로 구성됩니다.

1. 관련 제품들로 형성된 제품군 EX) "의자" + "소파" + "커피 테이블"
2. 해당 제품군의 여러가지 변형 EX) 위 예시들은 전부 "현대식" + "빅토리안" + "아르데코"

이제 당신이 새로운 개별 가구 객체를 생성했을 때, 이 객체들이 기존의 같은 패밀리 내에 있는 다른 가구 객체들과 일치하는 스타일을 가지도록 할 방법이 필요합니다. 그 이유는 당신의 고객이 스타일이 일치하지 않는 가구 세트를 받으면 크게 실망할 수 있기 때문입니다.

또, 가구 공급업체들은 카탈로그를 매우 자주 변경하기 때문에, 그들은 새로운 제품 또는 제품군을 추가할 때 마다 기존 코드를 변경해야 하는 번거로움을 피하고 싶을 것입니다.

## 해결책
추상 팩토리 패턴의 첫 번째 방안은 각 제품군에 해당하는 개별적인 인터페이스를 명시적으로 선언하는 것입니다. 그 다음, 제품의 모든 변형이 인터페이스를 따르도록 합니다.

예를 들어 모든 "의자"의 변형들은 "의자" 인터페이스를 구현한다, 모든 "커피 테이블" 변형들은 "커피 테이블"의 인터페이스를 구현한다등의 규칙을 명시합니다.

다음 단계는 추상 팩토리를 선언하는 것입니다. 추상 팩토리는 제품군내의 모든 개별 제품들의 생성 메서드들이 목록화되어있는 인터페이스입니다.

다음은 제품군의 각 변형에 대해 추상 팩토리 인터페이스를 기반으로 별도의 팩토리 클래스를 생성합니다. 팩토리는 특정 종류의 제품을 반환하는 클래스입니다.

예를 들어 "현대식 가구 팩토리"에서는 다음 객체들만 생성할 수 있습니다. "현대식 의자", "현대식 소파", "현대식 커피 테이블"

클라이언트 코드는 자신에 해당하는 추상 인터페이스를 통해 팩토리들과 제품들 모두와 함께 작동해야 합니다. 그래야 클라이언트 코드에 넘기는 팩토리의 종류와 제품 변형들을 클라이언트 코드를 손상하지 않으며 자유자재로 변경할 수 있습니다.

클라이언트가 팩토리에 의자를 주문했다고 가정해봅시다. 클라이언트는 팩토리의 클래스들을 알 필요가 없으며, 팩토리가 어떤 변형의 의자를 생성할지 전혀 신경을 쓰지 않습니다. 클라이언트는 추상 "의자" 인터페이스를 사용하여, "현대식 의자"든 "빅토리아식 의자"든 종류에 상관없이 모든 의자를 항상 동일한 방식으로 주문하며, 그가 의자에 대하 아는 유일한 사실은 제품이 "앉을 수 있다" 메서드를 구현한다는 것뿐입니다. 그러나, 생성된 의자의 변형은 항상 같은 팩토리 객체에서 생성된 "소파" 또는 "커피 테이블"의 변형과 같을 것입니다.

여기에서 명확히 짚고 넘어가야 할 점이 있습니다. 클라이언트가 추상 인터페이스에만 노출된다면 실제 팩토리 객체를 생성하는 것은 무엇일까요? 일반적으로 프로그램은 초기화 단계에서 구상 팩토리 객체를 생성합니다. 그 직전에 프로그램은 환경 또는 구성 설정에 따라 팩토리 유형을 선택해야 합니다.

## 의사코드
다음 예시는 추상 팩토리패턴이 크로스 플랫폼 UI요소들을 생성하는 방법을 보여줍니다. 이 방법으로 요소들을 생성하면 클라이언트 코드는 구상 UI 클래스들과 결합하지 않으며, 모든 생성된 요소들은 선택된 운영 체제에 맞게 생성됩니다.

UI 요소들은 크로스 플랫폼 프로그램 내에서는 유사하게 동작할 것으로 예상되나, 다른 운영 체제 내에서는 약간씩 다르게 보일 것으로 예상됩니다. 또한 UI 요소들이 해당하는 운영 체제의 스타일과 일치하는지 확인하는 것도 당신의 책임입니다. 왜냐하면 당신의 프로그램이 윈도우에서 실행될 때 매킨토시 컨트롤을 랜더링하는 것을 원하지 않을 것이기 때문입니다.

작동 방식은 다음과 같습니다. 프로그램이 시작될 때 현재 소속된 운영 체제의 유형을 확인합니다. 그 후 프로그램은 이 정보를 사용하여 운영 체제와 일치하는 클래스에서 팩토리 객체를 생성합니다. 나머지 코드는 이 팩토리 객체를 사용하여 UI 요소들을 만듭니다. 이렇게 하면 잘못된 요소들이 생성되는 것을 방지할 수 있습니다.

위 방법을 사용하면 클라이언트 코드가 객체의 추상 인터페이스를 통해 작업하는 한 팩토리들과 UI 요소들의 구상 클래스들에 의존하지 않게 됩니다. 또 위 방법은 클라이언트 코드가 당신이 나중에 추가할 수 있는 다른 팩토리들과 UI 요소들을 지원할 수 있도록 합니다.

이것의 결과로 새로운 변형의 UI 요소를 프로그램에 추가할 떄마다 클라이언트 코드를 수정할 필요가 없어집니다. 이 요소들을 생성하는 새로운 팩토리 클래스를 만든 후 프로그램의 초기화 코드를 그 팩토리 클래스를 선택하도록 약간 수정하기만 하면 됩니다.

```
interface GUIFactory {
	createButton(): Button;
	createCheckbox(): Checkbox;
}

class WinFactory implements GUIFactory {
	createButton(): Button {
		return new WinButton();
	}

	createCheckbox(): Checkbox {
		return new WinCheckbox();
	}
}

class MacFactory implements GUIFactory {
	createButton(): Button {
		return new MacButton();
	}

	createCheckbox(): Checkbox {
		return new MacCheckbox();
	}
}

interface Button {
	paint();
}

class WinButton implements Button {
	paint() {

	}
}

class MacButton implements Button {
	paint() {
		
	}
}

interface Checkbox {
	paint();
}

class WinCheckbox implements Checkbox {
	paint() {

	}
}

class MacCheckbox implements Checkbox {
	paint() {
		
	}
}

class App {
	private factory: GUIFactory;
	private button: Button;

	constructor(factory: GUIFactory) {
		this.factory = factory
	}

	createUI() {
		this.button = factory.createButton();
	}

	paint() {
		this.button.paint();
	}
}

class AppConfig {
	main() {
		if (config.OS == "Windows")
            factory = new WinFactory();
        else if (config.OS == "Mac")
            factory = new MacFactory();
        else
            throw new Exception("Error! Unknown operating system.")

        const app = new App(factory)
	}
}
```

## 적용
추상 팩토리 패턴은 당신의 코드가 관련된 제품군의 다양한 제품군과 작동해야 하지만 해당 제품들의 구상 클래스들에 의존하고 싶지 않을 때 사용하세요.

왜냐하면 이러한 클래스들은 당신에게 미리 알려지지 않았을 수 있으며, 그 때문에 향후 확장성을 허용하기를 윈할 수 있기 때문입니다.

추상 팩토리 패턴은 제품군의 각 클래스에서부터 객체들을 생성할 수 있는 인터페이스를 제공합니다. 인터페이스를 통해 코드가 객체들을 생성하는 한 당신은 당신의 프로그램에서 이미 생성된 제품들과 일치하지 않는 잘못된 제품 변형을 생성하지 않을지 걱정할 필요가 없습니다.

코드에 클래스가 있고, 이 클래스의 팩토피 메서드들의 집합에서 기본 책임이 뚜렷하지 않을 때 추상 팩토리 패턴의 구현을 고려하세요.

잘 설계된 프로그램에서는 각 클래스는 하나의 책임만 가집니다. 클래스가 여러 제품 유형을 상대할 경우, 클래스의 팩토리 메서드들을 독립실행형 팩토리 클래스 또는 완전한 추상 팩토리 패턴 구현으로 추출할 가치가 있습니다.

## 구현 방법
1. 고유한 제품 유형들 대 변형 제품들을 나타내는 매트릭스를 매핑하세요.
2. 모든 제품 변형들에 대한 추상 제품 인터페이스들을 선언하세요. 그 후 모든 구상 제품 클래스들이 인터페이스를 구현하도록 하세요.
3. 추상 팩토리 인터페이스를 모든 추상 제품들에 대한 생성 메서드들의 집합과 함께 선언하세요.
4. 각 제품 변형에 대해 각각 하나의 구상 팩토리 클래스 집합을 구현하세요.
5. 프로그램 어딘가에 팩토리 초기화 코드를 생성하세요. 초기화 코드는 프로그램 설정또는 현재 환경에 따라 구상 팩토리 클래스 중 하나를 인스턴스화해야 합니다. 이 팩토리 객체를 제품으로 생성하는 모든 클래스들에 전달하세요.
6. 코드를 검토해서 제품 생성자에 대한 모든 직접 호출을 찾으세요. 이 호출들을 팩토리 객체에 대한 적절한 생성 메서드 호출로 교체하세요.

## 장점
1. 팩토리에서 생성되는 제품들의 상호 호환을 보장할 수 있습니다.
2. 구상 제품들과 클라이언트 코드 사이의 단단한 결합을 피할 수 있습니다.
3. 단일 책임 원칙: 제품 생성 코드를 한 곳으로 추출하여 코드를 더 쉽게 유지보수할 수 있습니다.
4. 개방/폐쇄 원칙: 기존 클라이언트 코드를 훼손하지 않고 제품의 새로운 변형들을 생성할 수 있습니다.

## 단점
1. 패턴과 함께 새로운 인터페이스들과 클래스들이 많이 도입되기 때문에 코드가 필요 이상으로 복잡해질 수 있습니다.